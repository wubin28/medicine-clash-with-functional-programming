{"cyber-dojo.sh":"rm -f *.class\nCLASSES=.:`ls /junit/*.jar | tr '\\n' ':'`\njavac -Xlint:unchecked -Xlint:deprecation -cp $CLASSES  *.java\nif [ $? -eq 0 ]; then\n  # run test classes even if they are inner classes\n  # remove voluminous stack trace from output\n  java -cp $CLASSES org.junit.runner.JUnitCore `ls -1 *Test*.class | grep -v '\\\\$' | sed 's/\\(.*\\)\\..*/\\1/'` | grep -Ev 'org.junit.runner|org.junit.internal|sun.reflect|org.junit.Assert|java.lang.reflect|org.hamcrest'\nfi\n","output":"MedicineClashTest.java:88: error: cannot find symbol\n            MedicineClash.of(customers, \"Codeine\", \"Prozac\", 90, LocalDate.now()).id);\n                                                                                 ^\n  symbol:   variable id\n  location: interface List<Customer>\n1 error\n","instructions":"Kata: Medicine Clash\n====================\n\nAs a Health Insurer,\nI want to be able to search for patients who have a medicine clash,\nSo that I can alert their doctors and get their prescriptions changed.\n\nHealth Insurance companies don’t always get such good press, but in \nthis case, they actually do have your best interests at heart. \nSome medicines interact in unfortunate ways when they get into your \nbody at the same time, and your doctor isn’t always alert enough to \nspot the clash when writing your prescriptions. Sometimes, medicine \ninteractions are only identified years after the medicines become \nwidely used, and your doctor might not be completely up to date. \nYour Health Insurer certainly wants you to stay healthy, so discovering \na customer has a medicine clash and getting it corrected is good for \nbusiness, and good for you!\n\nFor this Kata, you have a recently discovered medicine clash, and \nyou want to look through a database of patient medicine and prescription \nrecords, to find any patients who need to be alerted to the problem. \nCreate a “Patient” class, with a method “Clash” that takes as arguments \na list of medicines, and how many days before today to consider, \n(defaults to the last 90 days). It should return a collection of days \non which all the medicines were being taken during this time.\n\nThe biology of medicine clashes\n===============================\n\nWhen you take a pill of medicine, the active substance will be absorbed \nthrough the lining of the gut, and enter your bloodstream. That means \nit will be taken all over your body, and can do its work. For example, \nif you take a headache pill, the active substance in the drug will be \ntaken with your blood to where it can block your pain receptors. At \nthe same time, there are enzymes at work in your liver, which break \ndown medicinal substances they find in your bloodstream. Eventually \nall the medicine will be removed, so you have to take another pill \nif you want the effects to continue.\n\nIn the liver, there are several different enzymes working, and they \nare specialized in breaking down different substances. For example, \nthe “CYP 2C9” enzyme will break down ibuprofen, the active ingredient \nin many headache pills. The trouble is, there are other medicines which \nwill stop particular enzymes from doing their work, which can lead to \nan overdose or other ill effects.\n\nOne example is the clash between fluoxetine and codeine. Fluoxetine \nis known by its trade name “Prozac”, and is often taken for depression. \nCodeine is another ingredient in headache pills, and is actually \na “pro-drug”, so it works slightly differently. Codeine needs to be \nbroken down in the liver by the enzyme “CYP 2D6” into the active \nsubstance, morphine, before it will do anything. Fluoxetine has \nthe effect of blocking “CYP 2D6”, so if you take the two medicines \ntogether, you won’t get much painkilling effect from the codeine. \nThat could be depressing!\n\nThe solution to the problem is to take a different painkiller - \none that’s not affected by that liver enzyme. Simply switch codeine \nfor ibuprofen, and you should be a little happier!\n\nWith thanks to Sara Sjöberg for helping me to write this section.\n\nQuoted from Coding Dojo Handbook by Emily Bache\n","Java7DateTest.java":"import org.junit.*;\nimport static org.junit.Assert.*;\nimport java.util.Date;\nimport java.util.Calendar;\n\npublic class Java7DateTest {\n\n    @Test\n    public void should_create_a_date_for_just_now() {\n        Date date = new Date(); // just now!\n\n        assertEquals(date.toString(), date.toString());\n    }\n\n    @Test\n    public void should_create_a_date_for_a_specific_date() {\n        Calendar calendar = Calendar.getInstance(); // just now!\n        \n        calendar.set(2016, 0, 26); // January 26th, 2016. January is 0\n\n        assertEquals(calendar.getTime().toString(), \n            calendar.getTime().toString());\n    }\n\n    @Test\n    public void should_add_several_days_to_a_specific_date() {\n        Calendar calendar = Calendar.getInstance(); // just now!\n        calendar.set(2016, 0, 26); // January 26th, 2016. January is 0\n\n        calendar.add(Calendar.DAY_OF_MONTH, 7);\n\n        assertEquals(calendar.getTime().toString(), \n            calendar.getTime().toString());\n    }\n\n    @Test\n    public void date_class_is_mutable_in_java_7_but_not_in_java_8() {\n        Date current = new Date();\n        User user = new User(current);\n        Date date = user.getCreationDate();\n\n        date.setTime(0L);\n\n        assertEquals(current.toString(), \n            user.getCreationDate().toString());\n    }\n\n    @Test\n    public void use_a_defensive_copy_to_prevent_mutable_date_class() {\n        Date current = new Date();\n        User user = new User(current);\n        Date date = user.getCreationDateImmutable();\n\n        date.setTime(0L);\n\n        assertEquals(current.toString(), \n            user.getCreationDateImmutable().toString());\n    }\n\n}\n","Java8DateTest.java":"import org.junit.*;\nimport static org.junit.Assert.*;\nimport java.time.Instant;\nimport java.time.Duration;\nimport java.time.LocalDate;\nimport java.time.Month;\nimport java.time.Period;\nimport java.time.temporal.ChronoUnit;\n\npublic class Java8DateTest {\n\n    // TODO: the_1st_concept_is_Instant_which_is_a_point_on_the_time_line\n    // TODO: the_2nd_concept_is_Duration_which_is_the_elapsed_time_between_two_instants\n\n    @Test\n    public void the_3rd_concept_is_LocalDate_which_covers_the_birthday_case() {\n        LocalDate now = LocalDate.now();\n        LocalDate birthday = LocalDate.of(1970, Month.OCTOBER, 28);\n        LocalDate oneMonthBeforeBirthday = birthday.minusDays(30);\n\n        assertEquals(now.toString(), now.toString());\n        assertEquals(\"1970-10-28\", birthday.toString());\n        assertEquals(\"1970-09-28\", oneMonthBeforeBirthday.toString());\n        assertTrue(birthday.isAfter(oneMonthBeforeBirthday));\n        assertTrue(oneMonthBeforeBirthday.isBefore(birthday));\n    }\n\n    @Test\n    public void the_4th_concept_is_Period_which_is_the_amount_of_time_between_two_LocalDate() {\n        LocalDate now = LocalDate.now();\n        LocalDate birthday = LocalDate.of(1970, Month.OCTOBER, 28);\n\n        assertEquals(45, birthday.until(now).getYears());\n        assertEquals(16557, birthday.until(now, ChronoUnit.DAYS));\n    }\n\n    // TODO: the_5th_concept_is_DateAdjuster_which_is_useful_to_add_or_substract_an_amount_of_time_to_an_Instant_or_a_LocalDate() {\n    // TODO: the_6th_concept_is_LocalTime_which_is_a_time_of_a_day\n    // TODO: the_7th_concept_is_ZonedTime_which_is_the_time_zone_all_over_the_earth\n\n    @Test\n    public void the_1st_concept_is_Instant_which_is_a_point_on_the_time_line() {\n        Instant now = Instant.now();\n\n        assertEquals(now.toString(), now.toString());\n    }\n\n    @Test\n    public void the_2nd_concept_is_Duration_which_is_the_elapsed_time_between_two_instants() {\n        Instant start = Instant.now();\n        for (int i = 0; i < 100000; i++) {\n        }\n        Instant end = Instant.now();\n\n        Duration elapsed = Duration.between(start, end);;\n        long milliseconds = elapsed.toMillis();\n\n        assertEquals(milliseconds, milliseconds);\n    }\n\n}\n","MedicineClashTest.java":"import org.junit.*;\nimport static org.junit.Assert.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.time.LocalDate;\nimport java.util.Arrays;\n\npublic class MedicineClashTest {\n\n    // GOAL: To find the a collection of days on which all the \n    //       given two clashed medicines were being taken during \n    //       a given period of time (defaults to the last 90 days).\n\n    // User story: As a Health Insurer,\n    //             I want to be able to search for patients who have \n    //                 a medicine clash,\n    //             So that I can alert their doctors and get their \n    //                 prescriptions changed.\n\n    // ID, CustomerName, Medicine, DispenseDate, daysSupply, DoctorName\n    // Customer(ID, Name, -Medicine-, -DispenseDate-, -daysSupply-, -DoctorName-)\n    //         \\\n    //         *\\\n    //         Medicine(Name, -DispenseDate-, -daysSupply-, -DoctorName-)\n    //            /\n    //          */\n    //         Prescription(DispenseDate, daysSupply, DoctorName)\n\n    @Test\n    public void no_clash_when_not_taking_both_medicines() {\n        List<Customer> customers = new ArrayList<>();\n        List<Medicine> medicines = new ArrayList<>();\n\n        medicines.add(new Medicine(\"Codeine\", \n            Arrays.asList(\n                new Prescription(LocalDate.now().minusDays(30), 30, \"Jason\")\n            )));\n\n        customers.add(\n            new Customer(\"110101197010104510\", \"Ben\", \n                medicines));\n        \n        assertEquals(new ArrayList<Customer>(), \n            MedicineClash.of(customers, \"Codeine\", \"Prozac\", 90, LocalDate.now()));\n    }\n\n    @Test\n    public void no_clash_when_no_overlap() {\n        List<Customer> customers = new ArrayList<>();\n        List<Medicine> medicines = new ArrayList<>();\n\n        medicines.add(new Medicine(\"Codeine\", \n            Arrays.asList(\n                new Prescription(LocalDate.now().minusDays(30), 30, \"Jason\")\n            )));\n        medicines.add(new Medicine(\"Prozac\", \n            Arrays.asList(\n                new Prescription(LocalDate.now().minusDays(90), 30, \"Alice\")\n            )));\n\n        customers.add(\n            new Customer(\"110101197010104510\", \"Ben\", \n                medicines));\n        \n        assertEquals(new ArrayList<Customer>(), \n            MedicineClash.of(customers, \"Codeine\", \"Prozac\", 90, LocalDate.now()));\n    }\n\n    @Test\n    public void two_medicines_taken_in_a_partially_overlapping_period() {\n        List<Customer> customers = new ArrayList<>();\n        List<Medicine> medicines = new ArrayList<>();\n\n        medicines.add(new Medicine(\"Codeine\", \n            Arrays.asList(\n                new Prescription(LocalDate.now().minusDays(30), 30, \"Jason\")\n            )));\n        medicines.add(new Medicine(\"Prozac\", \n            Arrays.asList(\n                new Prescription(LocalDate.now().minusDays(40), 40, \"Alice\")\n            )));\n\n        customers.add(\n            new Customer(\"110101197010104510\", \"Ben\", \n                medicines));\n        \n        assertEquals(\"110101197010104510\", \n            MedicineClash.of(customers, \"Codeine\", \"Prozac\", 90, LocalDate.now()).id);\n    }\n\n    // TODO: two_medicines_taken_overlapping_start_of_period\n    // TODO: two_medicines_taken_overlapping_current_date\n    // TODO: clash_when_medicines_taken_continuously\n    // TODO: clash_when_one_medicine_taken_on_some_of_the_days\n}","User.java":"import java.util.Date;\n\npublic class User {\n    private Date creationDate;\n\n    public User(Date creationDate) {\n        this.creationDate = creationDate;\n    }\n\n    public Date getCreationDate() {\n        return this.creationDate;\n    }\n\n    public Date getCreationDateImmutable() {\n        return new Date(this.creationDate.getTime());\n    }\n}","Customer.java":"import java.util.List;\n\npublic class Customer {\n    public String id;\n    public String name;\n    public List<Medicine> medicines;\n\n    public Customer(String id, String name, List<Medicine> medicines) {\n        this.id = id;\n        this.name = name;\n        this.medicines = medicines;\n    }\n\n    @Override\n    public String toString() {\n        return \"Customer \" + this.name + \" (\" + this.id + \") taking medicines \" + this.medicines;\n    }\n\n    @Override\n    public boolean equals(Object obj) { \n        if (obj == this)\n            return true;\n        if (!(obj instanceof Customer))\n            return false;\n        Customer customer = (Customer) obj; \n        return customer.id == this.id &&\n            customer.name == this.name;\n    }\n\n    @Override\n    public int hashCode() {\n        int hashValue = 11;\n        hashValue = 31 * hashValue + name.hashCode(); \n        hashValue = 31 * hashValue + id.hashCode(); \n        return hashValue;\n    }\n}\n\n","Medicine.java":"import java.util.List;\n\npublic class Medicine {\n    public String name;\n    public List<Prescription> prescriptions;\n\n    public Medicine(String name, List<Prescription> prescriptions) {\n        this.name = name;\n        this.prescriptions = prescriptions;\n    }\n\n    @Override\n    public String toString() {\n        return \"Medicine \" + this.name + \" with prescriptions \" + this.prescriptions;\n    }\n}","MedicineClash.java":"import java.util.List;\nimport java.util.stream.Stream;\nimport java.util.stream.Collectors;\nimport java.time.LocalDate;\n\npublic class MedicineClash {\n    public static List<Customer> of(\n            List<Customer> customers,\n            String medicineName,\n            String clashingMedicineName,\n            long daysBeforeToday, \n            LocalDate now) {\n\n        // TODO: tests covering the following\n        return customers.stream()\n            .filter(customer -> customer.medicines.size() == 2 &&\n                ((customer.medicines.get(0).name == medicineName &&\n                    customer.medicines.get(1).name == clashingMedicineName) ||\n                 (customer.medicines.get(0).name == clashingMedicineName &&\n                    customer.medicines.get(1).name == medicineName)\n                ) &&\n                customer.medicines.get(0).prescriptions.size() >= 1 &&\n                customer.medicines.get(1).prescriptions.size() >= 1\n            )\n            .filter(customer -> \n                MedicineClash.isOverlapped(customer, daysBeforeToday, now))\n            .collect(Collectors.toList());\n    }\n\n    public static boolean isOverlapped(\n            Customer customer,\n            long daysBeforeToday, \n            LocalDate now) {\n        LocalDate startA = \n            customer.medicines.get(0).prescriptions.get(0).dispenseDate;\n        LocalDate endA = \n            customer.medicines.get(0).prescriptions.get(0).dispenseDate\n                .plusDays(customer.medicines.get(0).prescriptions.get(0).daysSupply);\n        LocalDate startB = \n            customer.medicines.get(1).prescriptions.get(0).dispenseDate;\n        LocalDate endB = \n            customer.medicines.get(1).prescriptions.get(0).dispenseDate\n                .plusDays(customer.medicines.get(1).prescriptions.get(0).daysSupply);\n        \n        return !(startA.isAfter(endB) || endA.isBefore(startB)) \n            ? true : false;\n    }\n}","Prescription.java":"import java.time.LocalDate;\n\npublic class Prescription {\n    public LocalDate dispenseDate;\n    public int daysSupply;\n    public String doctorName;\n\n    public Prescription(LocalDate dispenseDate, int daysSupply, \n            String doctorName) {\n        this.dispenseDate = dispenseDate;\n        this.daysSupply = daysSupply;\n        this.doctorName = doctorName;\n    }\n\n    @Override\n    public String toString() {\n        return \"Prescription written on \" + this.dispenseDate + \n            \" for \" + this.daysSupply + \" days by \" + this.doctorName;\n    }\n}"}